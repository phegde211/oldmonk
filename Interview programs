1. Remove all occurances of a value in a single linked list.

void remove(struct llnode **head, int val)
{
    struct llnode *trav, *prev, *del;
    trav = prev = NULL;
    while (trav) {
          if (trav->data == val) {
              del = trav;
          }
          if (!del) {
              if (!prev) {
                  *head = trav;
              }
              prev = trav;
          }
          trav = trav->next;
          if (del) {
              free(del);
              del = NULL;
              if (prev) {
                  prev->next = trav;
          }
    }
    if (!prev) {
        *head = NULL;
    }
}


2. Maximum Subarray
 Find the contiguous subarray within an array (containing at least one number) which has the largest sum.For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
 the contiguous subarray [4,-1,2,1] has the largest sum = 6.
 
 /* a = array of nos, len = length of the array, lindex = left index of subaray, rindex = right index of subarray */
 void subarr(int *a, int len, int *lindex, int *rindex)
 {
    int ws = i = j = 0;
    int max = MINMAX or -2 pow 32-1. 
    while (j < len) {
        ws += a[j];
        if (ws > max) {
            max = ws;
            *lindex = i;
            *rindex = j;
        }
        j++;
        while (i < j && ws < 0) {
            ws -= a[i];
            i++;
        }
    }
    return;
 }
 
3. Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).Example 1:
Input: [1,3,5,4,7]
Output: 3
Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. 
Even though [1,3,5,7] is also an increasing subsequence, it’s not a continuous one where 5 and 7 are separated by 4.Example 2:
Input: [2,2,2,2,2]
Output: 1
Explanation: The longest continuous increasing subsequence is [2], its length is 1.

int func(int *a, int len)
{
    int i = j = count = 0;
    while (j < len) {
        j++;
        count = MAX(count, j-i);
        if (j < len && a[j] <= a[j-1]) {
            i = j;  /* Resetting i to j */
        }
    }
    return(count);
 }
 
 4. Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.Example:Input: s = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: the subarray [4,3] has the minimal length under the problem constraint.

int func(int *a, int len, int sum)
{
    int i = j = cursum = 0;
    while (j < len) {
        cursum += j;
        j++;
        while (i < j && cursum >= sum) {
            minlen = MIN(minlen, (j - i));
            cursum -= a[i];
            i++;
        }
    }
    if (minlen < len+1) 
        return (minlen);
    else 
        return 0;
}

5. 
